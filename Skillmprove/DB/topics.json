{
    "questions": [
        {
            "text": "How would you explain Dynamic Type to a new iOS developer?",
            "answer": "Dynamic Type is a way of allowing the user to adjust their preferred size for all fonts in all apps, and it's surprisingly easy to use from both a developer and user perspective",
            "category": "Accessibility",
            "complexity": "Easy"
        }, {
            "text": "What are the main problems we need to solve when making accessible apps?",
            "answer": "Visual impairment, color blindness, touch problems, and audio problems",
            "category": "Accessibility",
            "complexity": "Easy"
        }, {
            "text": "How is a dictionary different from an array?",
            "answer": "Arrays must be accessed using the index of each element, whereas dictionaries can be accessed using something you define – strings are very common.",
            "category": "Data Structures",
            "complexity": "Easy"
        }, {
            "text": "What are the main differences between classes and structs in Swift?",
            "answer": "Structure is a value type, class is a reference type",
            "category": "Swift",
            "complexity": "Easy"
        }, {
            "text": "What are tuples and why are they useful?",
            "answer": "Tuples are a bit like anonymous structs, and are helpful for returning multiple values from a method in a type-safe way, among other things.",
            "category": "Swift",
            "complexity": "Easy"
        }, {
            "text": "What does the Codable protocol do?",
            "answer": "This protocol was introduced in Swift 4 to let us quickly and safely convert custom Swift types to and from JSON, XML, and similar.",
            "category": "Swift",
            "complexity": "Easy"
        }, {
            "text": "What is the difference between an array and a set?",
            "answer": "Sets can’t contain duplicates and are unordered, so lookup is significantly faster. Sets can be thousands of times faster than arrays depending on how many elements they contain.",
            "category": "Data Structures",
            "complexity": "Easy"
        }, {
            "text": "What is the difference between the Float, Double, and CGFloat data types?",
            "answer": "Float is always 32-bit, Double is always 64-bit, and CGFloat is either 32-bit or 64-bit depending on the device it runs on, but realistically it’s just 64-bit all the time. Note that Swift 5 allows us to use CGFloat and Double interchangeably",
            "category": "Swift",
            "complexity": "Medium"
        }, {
            "text": "What’s the importance of key decoding strategies when using Codable?",
            "answer": "Key decoding strategies let us handle difference between JSON keys and property names in our Decodable struct. It’s common for JSON keys to use snake_case for key names, whereas in Swift we prefer camelCase, so we need to use a key decoding strategy to convert between the two.",
            "category": "Swift",
            "complexity": "Medium"
        }, {
            "text": "When using arrays, what’s the difference between map() and compactMap()?",
            "answer": "The map() transforms a sequence using a function we specify, whereas compactMap() does that same step but then unwraps its optionals and discards any nil values",
            "category": "Swift",
            "complexity": "Easy"
        }, {
            "text": "Why is immutability important?",
            "answer": "First, immutability makes your code easier to reason about. Second, Swift can optimize it more efficiently. If Swift knows a value can’t be changed, it can in theory store your data in a more efficient way",
            "category": "Swift",
            "complexity": "Medium"
        }, {
            "text": "What are one-sided ranges and when would you use them?",
            "answer": "One-sided ranges are ranges where you don’t specify the start or end of the range, meaning that Swift will automatically make the range start from the start of the collection or the end of the collection. They are useful when you want to read from a certain position to the end of a collection, such as if you want to skip the first 10 users in an array.",
            "category": "Swift",
            "complexity": "Medium"
        }, {
            "text": "What does it mean when we say \"strings are collections in Swift\"?",
            "answer": "Swift’s String type conform to the Collection protocol, which allows us to loop over characters, count how long the string is, map the characters, select random characters, and more.",
            "category": "Swift",
            "complexity": "Medium"
        }, {
            "text": "What is a UUID, and when might you use it?",
            "answer": "UUID stands for \"universally unique identifier\", which is a long string of hexadecimal numbers stored in a single type.\nUUIDs are helpful for ensuring some value is guaranteed to be unique, for example you might need a unique filename when saving something.",
            "category": "Swift",
            "complexity": "Medium"
        }, {
            "text": "What's the difference between a value type and a reference type?",
            "answer": "Reference types share a single copy of their data while value types keep a unique copy of their data.\nSwift represents a reference type as a class.\nThere are many kinds of value types in Swift, such as struct, enum, and tuples. ",
            "category": "Swift",
            "complexity": "Medium"
        }, {
            "text": "When would you use Swift’s Result type?",
            "answer": "Result is an enum encapsulating success and failure, both with associated values so you can attach extra information.\nYou should use \"Result\" when working with asynchronous code especially with network requests.",
            "category": "Swift",
            "complexity": "Medium"
        }, {
            "text": "What is type erasure and when would you use it?",
            "answer": "Type erasure allows us to throw away some type information, for example to say that an array of strings is actually just AnySequence – it’s a sequence containing strings, but we don’t know exactly what kind of sequence. This is particularly useful when types are long and complex, which is often the case with Combine. This is also useful when you want to return different types depending on the condition, for example, an array of strings or an array of int.",
            "category": "Swift",
            "complexity": "Hard"
        }, {
            "text": "How would you explain delegates to a new Swift developer?",
            "answer": "Delegation allows you to have one object act in place of another, for example your view controller might act as the data source for a table.",
            "category": "Design patterns",
            "complexity": "Easy"
        }, {
            "text": "Can you explain MVC, and how it's used on Apple's platforms?",
            "answer": "",
            "category": "Design patterns",
            "complexity": "Medium"
        }, {
            "text": "Can you explain MVVM, and how it might be used on Apple's platforms?",
            "answer": "",
            "category": "Design patterns",
            "complexity": "Medium"
        }, {
            "text": "How would you explain dependency injection to a junior developer?",
            "answer": "",
            "category": "Design patterns",
            "complexity": "Medium"
        }, {
            "text": "How would you explain protocol-oriented programming to a new Swift developer?",
            "answer": "",
            "category": "Design patterns",
            "complexity": "Medium"
        }, {
            "text": "What experience do you have of functional programming?",
            "answer": "",
            "category": "Design patterns",
            "complexity": "Medium"
        }, {
            "text": "Can you explain KVO, and how it's used on Apple's platforms?",
            "answer": "",
            "category": "Design patterns",
            "complexity": "Hard"
        }, {
            "text": "Can you give some examples of where singletons might be a good idea?",
            "answer": "",
            "category": "Design patterns",
            "complexity": "Hard"
        }, {
            "text": "What are phantom types and when would you use them?",
            "answer": "Phantom types are a type that doesn’t use at least one its generic parameters – they are declared with a generic parameter that isn’t used in their properties or methods.\nEven though we don’t use the generic type parameter, Swift does, which means it will treat two instances of our type as being incompatible if their generic type parameters are different. They aren’t used often, but when they are used they help the compiler enforce extra rules on our behalf – they make bad states impossible because the compiler will refuse to build our code.",
            "category": "Design patterns",
            "complexity": "Hard"
        }, {
            "text": "What is an array?",
            "answer": "An array stores values of the same type in an ordered list. The same value can appear in an array multiple times at different positions. The type of a Swift array is written in full as Array<Element>, where Element is the type of values the array is allowed to store. You can also write the type of an array in shorthand form as [Element]. Although the two forms are functionally identical, the shorthand form is preferred.",
            "category": "Collection Types",
            "complexity": "Easy"
        }, {
            "text": "How to create an empty array?",
            "answer": "There are three ways to create an empty array:\n1.\tvar someInts: [Int] = []\n2.\tvar someInts = Array<Int>()\n3.\tvar someInts = [Int]()",
            "category": "Collection Types",
            "complexity": "Easy"
        }
    ]
}
